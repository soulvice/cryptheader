#!/usr/bin/ash

config_read() {
	confile=$1
	if [ -f ${confile} ]; then
		# echo "Reading passport configuration..." >&2
		# check if the file containers something we don't want
		CONFIG_SYNTAX="(^\s*#|^\s*$|^\s*[a-z_][^[:space:]]*=[^;&]*$)"
		if egrep -q -iv "${CONFIG_SYNTAX}" "${confile}"; then
			# echo "Invalid configuration file" >&2
			return 0
		fi
		source "${confile}"
	else
		# echo "Configuration file doesn't exist" >&2
		return 0
	fi
}

passport_validate() {
	local pp_dev=$1
	local pp_fstype=$2
	local pp_file=$3

	local tppdir="./tpp_dir"
	local tppfile="./tpp_file"
	local pass="CuntLips"
	
	# check passport device exists
	if resolved=$(resolve_device "${pp_dev}" "${rootdelay}"); then
		# create temp passport directory
		[ -d "${tppdir}" ] || mkdir "${tppdir}"
		# delete passport file if already exists
		[ -f "${tppfile}" ] && rm -f "${tppfile}"
		# mount passport device and copy passport file
		mount -r -t "${pp_fstype}" "${resolved}" "${tppdir}"
		dd if="${tppdir}/${pp_file}" of="${tppfile}" >/dev/null 2>&1	
		umount "${tppdir}"
		
		# decrypt passport
		if eval openssl aes-256-cbc -d -a -salt -in ${tppfile} -k ${pass} | tar xvz -C ${tppdir} >/dev/null; then
			# read main config file
			if config_read "${tppdir}/config"; then
				# generate ranges
				#indexes=$(eval echo "{1..$device_count}")
				for idx in $(seq 1 $device_count); do
					dev_conf=$(echo "${tppdir}/dev_${idx}.conf")
					msg ":: Read configuration ${dev_conf}"
					# read crypt device config for $idx
					if config_read ${dev_conf}; then
						msg ":: Attempting to unlock device $(echo ${device})"
						# validate device if of LUKS
						if open_disk ${device} ${name} "${tppdir}/dev_${idx}.key" "${tppdir}/dev_${idx}.head"; then
							# disk unlocked
							msg ":: UNLOCKED ${device}"
						fi
					else
						err ":: Failed to read $(echo ${dev_conf})"
						exit 1
					fi
				done
				
				# export important values
				if [ ! -z ${root_device+x} ]; then
					# read root device config again
					dev_conf=$(echo "${tppdir}/${root_device}.conf")
					if config_read "${dev_conf}"; then
						export root="/dev/mapper/${name}"
						export rootfstype="${fstype}"
						[ ! -z ${root_flags+x} ] && export rootflags="${root_flags}"
					else
						err ":: Unable to read root device configuration file"
						exit 1
					fi
				fi
			else
				err ":: Unable to read passport main configuration file"
				exit 1
			fi
			
			# clean up files
			[ -d "${tppdir}" ] && rm -rf "${tppdir}"
			[ -f "${tppfile}" ] && rm -f "${tppfile}"
		else
			err ":: Unable to open passport for validation"
			exit 1
		fi
	else
		err ":: Unable to resolve passport device"
		exit 1
	fi
}

#
# open disk
#
# open_disk <device> <cryptname> <key> <head>
#
open_disk() {
	local device=$1
	local cryptname=$2
	local cryptkey=$3
	local crypthead=$4

	# check key exists
	if [ ! -f "${cryptkey}" ]; then
		err ":: Crypt key ${cryptkey} does not exist"
		return 0
	fi

	# check head exists
	if [ ! -f "${crypthead}" ]; then
		err ":: Crypt head ${crypthead} does not exist"
		return 0
	fi

	if resolved=$(resolve_device "${device}" "${rootdelay}"); then
		if cryptsetup isLuks ${resolved} >/dev/null 2>&1 || cryptsetup isLuks ${crypthead} >/dev/null 2>&1; then
			if eval cryptsetup open --type luks --key-file ${cryptkey} --header ${crypthead} ${resolved} ${cryptname}; then
				msg ":: ${device} unlocked"
				return 1
			else
				err ":: Failed to unlocked device ${device}"
				return 0
			fi
		else
			err ":: ${device} is not a LUKS device"
			return 0
		fi
	else
		err ":: Unable to resolve device ${device}"
		return 0
	fi
	err ":: Somethng went wrong, should not have made it this far"
	return 0
}


run_hook() {
	modprobe -a -q dm-crypt >/dev/null 2>&1
	[ "${quiet}" = "y" ] && CSQUIET=">/dev/null"
	
	# Passport
	# passportdevice=/dev/mapper/key-passport:ext4:/passport.nacl
	# passportdevice=<device>:<fstype>:<file>
	
	IFS=: read pdev pfstype pfile <<EOF
$passportdevice
EOF
	if passport_validate "${pdev}" "${pfstype}" "${pfile}"; then
		msg ":: Passport ${pfile} - Complete"	
	fi
}

# vim: set ft=sh ts=4 sw=4 et:
